# todo
1. 将cmd中的参数解析和运行分离，类似于update命令，将init和rollback逻辑封装到单独的目录的库中。
2. 任何意料之外的、或经过必要重试步骤仍然失败的错误都要报错并一直向外传递，不允许自作主张直接忽略或者continue。你要纠正一个认识：除了异步更新的常驻协程本身不能退出以外，异步更新view每次循环内部的逻辑，init的逻辑，rollback逻辑，都需要尽力把错误抛到最外层，直到退出程序。
3. 将rollback逻辑重构一下，先确认每个db下有哪些表是共同表，再针对每张表进行回滚。判断逻辑是先确认表与view是否同时存在，是的话再确认ck中是否要对应的表，是的话则可以确认是共同表。回滚时，逻辑仍然是先删除view，再改表名，最后删除ck中表列。如果某个表回滚失败，要立即停止回滚并报错，传递到外部直到退出。注意中间状态下的场景的健壮性，需要兼容以下几种情形：当前有的表可能没有新建对应的视图，但是sr的表已经重命名了；sr表没有任何改动，但是ck已经添加了列；catalog可能没有创建。
4. 将回滚需要获取异步更新view的分布式锁
5. 将ck和sr的如连接超时时间等连接参数配置化，并全面做好配置的严格校验，不限于当前新增的参数。
6. 对ddl解析的超时时间也配置化

# 要求
1. 不要考虑 backward compatibility
2. 错误处理设计（更新，简要版）
   - 总则：除业务性跳过外，所有错误必须向外抛出，直到退出程序。
   - 重试：数据库查询/执行统一走 retry 包；重试耗尽仍失败则上抛，不允许“warn 后继续”。
   - 遍历：凡使用 rows.Next 遍历，循环后必须检查 rows.Err；如有错误立即返回。
   - 枚举/批量：返回集合的函数遇错立即返回 error，不返回部分结果；批量执行遇任一错误立刻返回。
   - 常驻协程：进程不退出，但每次调度循环内部失败必须上抛并记录；由调度控制进入下一轮。
   - 业务性跳过（不视为错误）：解析器跳过注释/空行；字段构造器不需新增列返回空串；视图构建按业务策略跳过 SR 不存在的字段（记录 warn）。
   - 日志规范：错误日志必须包含库/表/列/操作与原始错误；Warn 仅用于业务跳过/非致命信息，绝不用于压制错误。
