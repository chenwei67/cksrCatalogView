# rollback逻辑重构
## 功能简述
将当前的批量回滚逻辑进行重构，将其拆分成两个阶段：先确认共同表，再针对每张表进行回滚。所有数据库对处理完毕后，对所有数据库对的catalog删除。注意由于不同数据库对的catalog是可以复用的，所以删除之前需要确认存在性。
## 确认共同表
判断逻辑是先确认表与view是否同时存在，是的话再确认ck中是否存在对应的表，是的话则可以确认是共同表。但需要兼容以下几种情形:
1. 当前有的表可能没有新建对应的视图，但是sr的表已经重命名了，此时配合ck中的表名是否与sr表名去掉后缀后一致，确认是否是共同表。
2. 不仅对应的视图没创建，而且sr表名没有修改，但是ck已经添加了列，此时配合sr与ck的表名是否一致，确认是否是共同表。
3. sr视图，表名，ck列都没有变更，但是catalog创建了
4. catalog都没有创建，什么都不处理
## 回滚逻辑
回滚时，逻辑是先删除view，再改表名，最后删除ck中表列，数据库对处理完毕后再整体删除catalog。要支持策略性配置，根据配置的策略，决定在某个表回滚失败，要立即停止回滚并报错，传递到外部直到退出还是跳过当前的错误只打印错误日志。注意中间状态下的场景的健壮性。

# 要求
1. 不要考虑 backward compatibility
2. 错误处理设计（更新，简要版）
   - 总则：除业务性跳过外，所有错误必须向外抛出，直到退出程序。
   - 重试：数据库查询/执行统一走 retry 包；重试耗尽仍失败则上抛，不允许“warn 后继续”。
   - 遍历：凡使用 rows.Next 遍历，循环后必须检查 rows.Err；如有错误立即返回。
   - 枚举/批量：返回集合的函数遇错立即返回 error，不返回部分结果；批量执行遇任一错误立刻返回。
   - 常驻协程：进程不退出，但每次调度循环内部失败必须上抛并记录；由调度控制进入下一轮。
   - 业务性跳过（不视为错误）：解析器跳过注释/空行；字段构造器不需新增列返回空串；视图构建按业务策略跳过 SR 不存在的字段（记录 warn）。
   - 日志规范：错误日志必须包含库/表/列/操作与原始错误；Warn 仅用于业务跳过/非致命信息，绝不用于压制错误。